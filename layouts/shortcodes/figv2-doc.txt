Fig Version 2

Figure code that uses a JSON encoded pre-compiled asset cache for improved
performance at scale.

The primary bottle neck in version 1 was file I/O at scale, and publishing
resources unnecessarily, generating much more HTML/XML than needed. This made
site rebuilds in development take so long that it impacted writing 
productivity. (See _figv1.backup comments for a fuller discussion of the 
underlying mismatch and tradeoffs.) 

Improving this situation involved several tactics:
  - An upgrade to Go and Hugo, I was a few years behind, and many performance
    improvements had been made, and also a better ability to define reusable 
    resources across the site, directly relevant to what I needed.
  - I made aggressive configuration and module mounting optimizations, 
    including shutting off automatic page generation on image metadata files.
  - I created an asset cache in JSON format to store image metadata more
    efficiently as pre-loaded JSON data in the site, eliminating all
    individual resource.Get calls.
  - I greatly optimized the fig code, splitting into shortcode and partial,
    statically referencing the image in dev (no resource.Get calls) and only 
    doing image manipulation in production.
  - I implemented the idea of blocks, resusable text objects, which could
    greatly influence future site organization, but its immediate effects
    are to constrain both editing focus and the scope of incremental rebuilds.

These changes resulted in server startups under half a second with incremental
rebuilds under 200ms on the high end, and often much less than that. This 
should allow me to scale the scope of the site more sustainably going forward.
In the shorter term, it greatly reduces resistance/friction. Through this work
I also made optimizations to many supporting scripts, nvim integration, etc.,
that reduced overall friction with a better integrated and more efficient
workflow.

A small Python script at undergo/scripts/compile-assets.py recursively walks
the asset file hierarchy, compiling YAML metadata into JSON for use by the fig 
shortcode. By leveraging Hugo's built-in data handling capabilities, all asset
data in the cache is automatically read once at server start-up and is then 
available instantaneously in memory in the shortcode. 

Furthermore, image manipulation functions in the shortcode are bypassed in 
the development environment, as in that environment, bandwidth is not a 
bottleneck, and I would prefer to optimize build performance in development 
instead to reduce writing resistance.

(I started the cache compiling code in Go, both for consistency and performance,
but found that it was overly complicated for what I wanted to do. There was 
too much boilerplate, scaffolding, and other environmental dependencies. 
Python is much more straightforward, and I optimized it at the code level.)

The cache code is run and optimized in the following ways:

  - All scripts in undergo/scripts are added to the PATH by .envrc. 
  - All code is run from the top level Hugo directory.
  - Paths are relative to the top level Hugo directory, in other words, 
    starting with "content/...".
  - The code uses Thread Pools for quasi-parallel file I/O.
  - A parallel index in JSON, with modification times for each key, is also 
    generated and stored so that the cache can be incrementally updated, 
    further minimizing file I/O. This index is above /data so Hugo doesn't 
    ingest it when building.
  - Deleting the index file will force a full cache rebuild. (Of course, so 
    will deleting the cache file itself.)
  - Incremental updates automatically prune cache entries for files that have
    been moved or deleted.
  - A specific record can be updated by passing the --changed flag with a key.
  - An inotify watcher at undergo/scripts/watch-assets.sh will trigger a
    --changed call to compile-assets.py automatically whenever a *.md  file is 
    modified.
  - New images are copied into the publish_dir for immediate static access in
    development environment.
   
The fig shorcode was updated to use this cache and to be more clearly 
organized and performance optimized overall. For example, file globbing used
in version 1 has been replaced with explicit paths in version 2.

Obviously before both dev and prod builds, this cache must be refreshed.

On incremental index builds, the compile-assets.py script outputs basic fig 
shortcodes for new records to a file in the top level Hugo directory called 
figstoadd.txt. The following code triggers compile-assets from within Vi and 
automatically pastes the generated fig shortcodes for new files below the cursor
in the active buffer. The buffer is also automatically saved, meaning that not 
only will Hugo automatically load the asset cache when it sees it was updated, 
but navigatetochanged will be automatically triggered, meaning that when new 
assets are added to the cache, they will be displayed automatically in the 
browser.


" <F2>: execute a bash script compile-assets.sh in PATH, 
"       then read file stored in the shell PWD into buffer cursor location, 
"       then write buffer
"  â€” capture launch dir once, run script there, then read+write the file
if !exists('g:startdir') | let g:startdir = expand('$PWD') | endif
nnoremap <silent> <F2> :execute '! (cd ' . shellescape(g:startdir) . ' && compile-assets.sh)' <Bar> execute 'read ' . fnameescape(g:startdir . '/figstoadd.txt') <Bar> write<CR>


For the paths to work, Vi should be invoked from the top level Hugo directory. 
(Just default to doing everything from there.)

The fig shortcode was further optizimized by leaving all pararmeter handling,
(treating shortcode like a controller) and calling cached partial to render
fig html and cache the results so it only renders once.

memills.com is the reference implementation of this approach. The following
are the necessary components, each are documented inline:

  - hugo-utlities/dev.sh (runs dev server with optimized settings)
  - memills/config/_default/config.toml
        # an optimization that prevents Hugo from automatically copying these to publc (not needed there)
        ignoreFiles = ["^content/_assets/.*\\.md$"] 

          # override hugo default mapping to prevent unnecessary page generation in _assets
          [[module.mounts]]
            source = "content"
            target = "content"
            excludeFiles = ["_assets/**"] # intended effect: excludes all _assets .md files from automatic page generation 

          # mount assets as site wide resources instead
          # block access in BOTH dev and prod using resources.Get
          # fig/image access in prod using resources.Get to resize, crop 
          [[module.mounts]]
            source = "content/_assets"
            target = "assets"
  - memills/config/development/config.toml
  - undergo/scripts/compile-assets.[py,sh]
      - builds and updates JSON asset cache
      - copies new image files to publish_dir for immediate static access

  - undergo/layouts/shortcodes/fig.html, undergo/layouts/partials/fig-render.html
  - hugo-utilities/vim/*
      - nvim config files including keybindings to run compile-assets.sh and
        facilitate fig shortcode creation




(**** PRE Hugo 0.150 version****)
The post Hugo 0.150 changes summarized immediately above greatly simplify and 
improve the initial approach that follows. Currently, neither _index files nor
static mounts are needed any longer. Minimal configuration and environment 
changes are needed. 

# theming and reusable code
[module]
  _merge = "deep"
  [[module.imports]]
    path = "github.com/ajsmith607/undergo"

  # don't render pages for *.md files under /content/_assets
  [[module.mounts]]
    source = "content"
    target = "content"
    excludeFiles = ["/_assets/**/*.md"]    # path is relative to /content
    # re-add only the section's _index.md so its front matter applies
    # and it can be referenced as the images resource bundle in fig production shortcode
  [[module.mounts]]
    source = "content/_assets/_index.md"
    target = "content/_assets/_index.md"


The content of /content/_assets/_index.md is:


---
# Controls the section node itself
headless: true
outputs: []
build:
  list: never
  render: never
  publishResources: true    # in order to see the images at all 

# Push the same rules to all descendants
cascade:
  _target:
    path: "/_assets/**"    # children of this section
  outputs: []
  build:
    list: never
    render: never
    publishResources: true
---


The development environment is further optimized by shutting down all 
unnecessary output, and moving _assets to /static, thus avoiding all resource
publishing and I/O while keeping paths consistent, so no special code is 
needed to handle this, the shortcode works automatically in each case. 
Images are not resized and therefore are not optimized themselves,  but in 
developement, data is served locally, so bandwith is not an issue.


# --- development overrides ---
[environments.development]
disableKinds = ["RSS", "sitemap", "robotsTXT", "taxonomy", "term"]
resourceDir = "/dev/shm/hugo-resources"

  [environments.development.module]
    # Dev: mount everything except _assets as content
    [[environments.development.module.mounts]]
      source = "content"
      target = "content"
      excludeFiles = ["/_assets/**"]

    # Dev: serve _assets raw as static files, limit to images
    [[environments.development.module.mounts]]
      source = "content/_assets"
      target = "static/_assets"
      includeFiles = ["**/*.jpg","**/*.jpeg","**/*.png","**/*.webp","**/*.gif"]


In production, images must be under /content, not /static or /resources. 
The images must be treated as resources for dynamic scaling (which can't be 
done in /static, but must also be visible so the full original can be seen when 
anyone clicks "view largest available image" (which can't be done in 
/resources). By convention, _assets is directly under /content to be available
sitewide, and is named with a leading underscore to avoid name collisions.

To summarize:
  - In production, images under _assets are treated as resources under /content.
  - In development, images under _assets are treated statically under /static.

Typically, run development hugo server in fast render mode with no http 
caching, as most edits in that environment are one content page at a time.

For more information on why images must be under content, see the code comments
in version 1 of the fig shortcode: figv1.html. Inline comments in 
layouts/shortcodes/fig.html explains usage and shortcode implementation details.



