Fig Version 2

Figure code that uses a JSON encoded pre-compiled asset cache for improved
performance at scale.

The primary bottle neck in version 1 was file I/O at scale, and publishing
resources unnecessarily, generating much more HTML/XML than needed. This made
site rebuilds in development take so long that it impacted writing 
productivity. (See _figv1.backup comments for a fuller discussion of the 
underlying mismatch and  tradeoffs.)

A small Python script at undergo/scripts/compile-assets.py recursively walks
the asset file hierarchy, compiling metadata for use by the fig shortcode. By 
leveraging Hugo's built-in data handling capabilities, all asset data in the 
cache is automatically read once at server start-up and is then available 
instantaneously in memory in the shortcode. 

Furthermore, image manipulation functions in the shortcode are bypassed in 
the development environment, as in that environment, bandwidth is not a 
bottleneck, and I would prefer to optimize build performance in development 
instead.

(I started the cache compiling code in Go, both for consistency and performance,
but found that it was overly complicated for what I wanted to do. There was 
too much boilerplate, scaffolding, and other environmental dependencies. 
Python is much more straightforward, and I optimized it at the code level.)

The cache code is run and optimized in the following ways:

  - All scripts in undergo/scripts are added to the PATH by .envrc. 
  - All code is run from the top level Hugo directory.
  - Paths are relative to the top level Hugo directory, in other words, 
    starting with "content/...".
  - The code uses Thread Pools for quasi-parallel file I/O.
  - A parallel index in JSON, with modification times for each key, is also 
    generated and stored so that the cache can be incrementally updated, 
    further minimizing file I/O. This index is above /data so Hugo doesn't 
    ingest it when building.
  - Deleting the index file will force a full cache rebuild. (Of course, so 
    will deleting the cache file itself.)
  - Incremental updates automatically prune cache entries for files that have
    been moved or deleted.
  - A specific record can be updated by passing the --changed flag with a key.
  - An inotify watcher at undergo/scripts/watch-assets.sh will trigger a
    --changed call to compile-assets.py automatically whenever a *.md  file is 
    modified.
   
The fig shorcode was updated to use this cache and to be more clearly 
organized and performance optimized overall. For example, file globbing used
in version 1 has been replaced with explicit paths in version 2.

Obviously before both dev and prod builds, this cache must be refreshed.

Configuration for undergo module and production build optimizations:


# theming and reusable code
[module]
  _merge = "deep"
  [[module.imports]]
    path = "github.com/ajsmith607/undergo"

  # don't render pages for *.md files under /content/_assets
  [[module.mounts]]
    source = "content"
    target = "content"
    excludeFiles = ["/_assets/**/*.md"]    # path is relative to /content
    # re-add only the section's _index.md so its front matter applies
    # and it can be referenced as the images resource bundle in fig production shortcode
  [[module.mounts]]
    source = "content/_assets/_index.md"
    target = "content/_assets/_index.md"


The content of /content/_assets/_index.md is:


---
# Controls the section node itself
headless: true
outputs: []
build:
  list: never
  render: never
  publishResources: true    # in order to see the images at all 

# Push the same rules to all descendants
cascade:
  _target:
    path: "/_assets/**"    # children of this section
  outputs: []
  build:
    list: never
    render: never
    publishResources: true
---


The development environment is further optimized by shutting down all 
unnecessary output, and moving _assets to /static, thus avoiding all resource
publishing and I/O while keeping paths consistent, so no special code is 
needed to handle this, the shortcode works automatically in each case. 
Images are not resized and therefore are not optimized themselves,  but in 
developement, data is served locally, so bandwith is not an issue.


# --- development overrides ---
[environments.development]
disableKinds = ["RSS", "sitemap", "robotsTXT", "taxonomy", "term"]
resourceDir = "/dev/shm/hugo-resources"

  [environments.development.module]
    # Dev: mount everything except _assets as content
    [[environments.development.module.mounts]]
      source = "content"
      target = "content"
      excludeFiles = ["/_assets/**"]

    # Dev: serve _assets raw as static files, limit to images
    [[environments.development.module.mounts]]
      source = "content/_assets"
      target = "static/_assets"
      includeFiles = ["**/*.jpg","**/*.jpeg","**/*.png","**/*.webp","**/*.gif"]


In production, images must be under /content, not /static or /resources. 
The images must be treated as resources for dynamic scaling (which can't be 
done in /static, but must also be visible so the full original can be seen when 
anyone clicks "view largest available image" (which can't be done in 
/resources). By convention, _assets is directly under /content to be available
sitewide, and is named with a leading underscore to avoid name collisions.

To summarize:
  - In production, images under _assets are treated as resources under /content.
  - In development, images under _assets are treated statically under /static.

Typically, run development hugo server in fast render mode with no http 
caching, as most edits in that environment are one content page at a time.

For more information on why images must be under content, see the code comments
in version 1 of the fig shortcode: figv1.html. Inline comments in 
layouts/shortcodes/fig.html explains usage and shortcode implementation details.

On incremental index builds, the compile-assets.py script outputs basic fig 
shortcodes for new records to a file in the top level Hugo directory called 
figstoadd.txt. The following code triggers compile-assets from within Vi and 
automatically pastes the generated fig shortcodes for new files below the cursor
in the active buffer. The buffer is also automatically saved, meaning that not 
only will Hugo automatically load the asset cache when it sees it was updated, 
but navigatetochanged will be automatically triggered, meaning that when new 
assets are added to the cache, they will be displayed automatically in the 
browser.


" <F2>: execute a bash script compile-assets.sh in PATH, 
"       then read file stored in the shell PWD into buffer cursor location, 
"       then write buffer
"  â€” capture launch dir once, run script there, then read+write the file
if !exists('g:startdir') | let g:startdir = expand('$PWD') | endif
nnoremap <silent> <F2> :execute '! (cd ' . shellescape(g:startdir) . ' && compile-assets.sh)' <Bar> execute 'read ' . fnameescape(g:startdir . '/figstoadd.txt') <Bar> write<CR>


For the paths to work, Vi should be invoked from the top level Hugo directory. 
(Just default to doing everything from there.)
